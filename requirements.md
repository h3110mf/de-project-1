# Витрина RFM




## 1.1. Выясните требования к целевой витрине.

Постановка задачи выглядит достаточно абстрактно - постройте витрину. Первым делом вам необходимо выяснить у заказчика детали. Запросите недостающую информацию у заказчика в чате.

Зафиксируйте выясненные требования. Составьте документацию готовящейся витрины на основе заданных вами вопросов, добавив все необходимые детали.

-----------
**Требования к витрине:**

Необходимо построить витрину для сегментации клиентов по категориям:
Каждого клиента оценивают по трём факторам:
Recency (пер. «давность») — сколько времени прошло с момента последнего заказа.
Frequency (пер. «частота») — количество заказов.
Monetary Value (пер. «денежная ценность») — сумма затрат клиента.

Как провести RFM-сегментацию
Присвойте каждому клиенту три значения — значение фактора Recency, значение фактора Frequency и значение фактора Monetary Value:
Фактор Recency измеряется по последнему заказу. Распределите клиентов по шкале от одного до пяти, где значение 1 получат те, кто либо вообще не делал заказов, либо делал их очень давно, а 5 — те, кто заказывал относительно недавно.
Фактор Frequency оценивается по количеству заказов. Распределите клиентов по шкале от одного до пяти, где значение 1 получат клиенты с наименьшим количеством заказов, а 5 — с наибольшим.
Фактор Monetary Value оценивается по потраченной сумме. Распределите клиентов по шкале от одного до пяти, где значение 1 получат клиенты с наименьшей суммой, а 5 — с наибольшей.
Проверьте, что количество клиентов в каждом сегменте одинаково. Например, если в базе всего 100 клиентов, то 20 клиентов должны получить значение 1, ещё 20 — значение 2 и т. д.



**AS IS** - есть 2 схемы "production" и "analysis". 

Production содержит исходный материал для построения витрины
Analysis - абсолютно пустая 

**To do**
В analysis нужно создать представления из схемы Production и на базе них построить витрину. 

Для анализа нужно отобрать только успешно выполненные заказы. (со статусом **Closed**)

В витрине нужны данные **с начала 2022 года**.

Название витрины - **dm_rfm_segments**

Обновления не нужны (**без инкрементной загрузки**)

Витрина должна состоять из таких полей:
**user_id**
**recency (число от 1 до 5)**
**frequency (число от 1 до 5)**
**monetary_value (число от 1 до 5)**






## 1.2. Изучите структуру исходных данных.

Полключитесь к базе данных и изучите структуру таблиц.

Если появились вопросы по устройству источника, задайте их в чате.

Зафиксируйте, какие поля вы будете использовать для расчета витрины.

-----------

select * from production.orders
в таблице присутствует user_id, order_id, payment
user_id - напрямую идёт в витрину,
над cost а не Payment (как оказалось cost =payment + bonus. Теоретически бонус быть бонусами "спасибо", что тоже средства юзера, либо он мог оплатить только бонусами
(в требованиях заказчика другого не сказано)) 
в представлении будет надстройка по разбиению на категории для Monetary Value

над order_ts - надстройка по Resency по ближайшему времени заказа

над count(order_ts) возможно сделать надстройку по Frequency - по общему объёму заказов для конкретного пользователя системы

select * from production.orderstatuses
колонка key сообщает нам информацию о том, что требуемый статус - id - 4 (Closed). Хоть эта колонка по foreign key не связана с orders, из нее мы понимаем, что будем фильтровать orders по status = '4'

Orderstatuslog - так или иначе дублирует инфу по статусу заказа 4 (показывает все пути прохождения заказа от 1 до 4, либо от 1 до 5 ( не наш случай))

Products показывает информацию по меню и ценам (нас пока не интересует)

users также пока нас не интересует - имя пользователя при регистрации в базе данных и его ФИО


--!!!-----------------------------------------------
Итак, из выше сказанного для использования витрины мы используем:

User_id (из production.orders);
Cost (production.orders), над которым мы сделаем надстройку по ранжированию суммы и получим Monetary Value;
order_ts (production.orders), над которым мы сделаем надстройку по ранжированию последнего времени заказа;
также было принято решение делать count(orders_ts) для расчёта общего количества заказов со статусом Closed
-------------------------------------------------